function t(){const t=this[d],e=t.target;let o,r,n;for(e.reverse(),o=0,r=e.length;o<r;o++)if((n=e[o])&&"object"==typeof n){const i=n[d];i&&(i.ownKey=o)}var s=[new O(h,[],void 0,void 0,this)];return j(t,s),this}function e(t){const e=this[d],o=e.target;let r,n,s;for(o.sort(t),r=0,n=o.length;r<n;r++)if((s=o[r])&&"object"==typeof s){const i=s[d];i&&(i.ownKey=r)}return t=[new O(a,[],void 0,void 0,this)],j(e,t),this}function s(t,n,s){const i=this[d],h=i.target,a=[],e=h.length,l=h.slice(0);if(n=void 0===n?0:n<0?Math.max(e+n,0):Math.min(n,e),s=void 0===s?e:s<0?Math.max(e+s,0):Math.min(s,e),n<e&&n<s){h.fill(t,n,s);let r;for(let t=n,e,o;t<s;t++)e=h[t],h[t]=m(e,t,i),t in l?((o=l[t])&&"object"==typeof o&&(r=o[d])&&(o=r.detach()),a.push(new O(v,[t],h[t],o,this))):a.push(new O(w,[t],h[t],void 0,this));j(i,a)}return this}function i(n,t,e){const s=this[d],i=s.target,o=i.length;n=n<0?Math.max(o+n,0):n,t=void 0===t?0:t<0?Math.max(o+t,0):Math.min(t,o),e=void 0===e?o:e<0?Math.max(o+e,0):Math.min(e,o);var h=Math.min(e-t,o-n);if(n<o&&n!==t&&0<h){const a=i.slice(0),l=[];i.copyWithin(n,t,e);for(let t=n,e,o,r;t<n+h;t++)(e=i[t])&&"object"==typeof e&&(e=m(e,t,s),i[t]=e),(o=a[t])&&"object"==typeof o&&(r=o[d])&&(o=r.detach()),"object"!=typeof e&&e===o||l.push(new O(v,[t],e,o,this));j(s,l)}return this}const w="insert",v="update",g="delete",h="reverse",a="shuffle",d=Symbol.for("object-observer-meta-key-0"),l={async:1},f=(t,e)=>{const o={};o[d]=e;for(const r in t)o[r]=m(t[r],r,e);return o},p=(e,o)=>{var r=e.length;const n=new Array(r);n[d]=o;for(let t=0;t<r;t++)n[t]=m(e[t],t,o);return n},c=(t,e)=>(t[d]=e,t),b=(t,e)=>{if(null===t)return e;let o=e;if(t.path){const r=t.path;o=e.filter(t=>t.path.join(".")===r)}else if(t.pathsOf){const n=t.pathsOf,s=n.join(".");o=e.filter(t=>(t.path.length===n.length+1||t.path.length===n.length&&(t.type===h||t.type===a))&&t.path.join(".").startsWith(s))}else if(t.pathsFrom){const i=t.pathsFrom;o=e.filter(t=>t.path.join(".").startsWith(i))}return o},y=(e,o)=>{try{e(o)}catch(t){console.error(`failed to notify listener ${e} with `+o,t)}},u=function(){var t,e,o=this.batches;this.batches=[];for([t,e]of o)y(t,e)},j=(f,e)=>{let o=f,t,r,n,s,i,h;var p=e.length;do{for(t=o.options.async,r=o.observers,h=r.length;h--;)if([n,s]=r[h],(i=b(s,e)).length)if(t){0===o.batches.length&&queueMicrotask(u.bind(o));let t;for(const l of o.batches)if(l[0]===n){t=l;break}t||(t=[n,[]],o.batches.push(t)),Array.prototype.push.apply(t[1],i)}else y(n,i);var c=o.parent;if(c){for(let t=0;t<p;t++){var a=e[t];e[t]=new O(a.type,[o.ownKey,...a.path],a.value,a.oldValue,a.object)}o=c}else o=null}while(o)},m=(t,e,o)=>"object"!=typeof t||null===t?t:Array.isArray(t)?new E({target:t,ownKey:e,parent:o}).proxy:ArrayBuffer.isView(t)?new S({target:t,ownKey:e,parent:o}).proxy:t instanceof Date?t:new K({target:t,ownKey:e,parent:o}).proxy,x={pop:function(){const t=this[d],e=t.target,o=e.length-1;let r=e.pop();if(r&&"object"==typeof r){const s=r[d];s&&(r=s.detach())}var n=[new O(g,[o],void 0,r,this)];return j(t,n),r},push:function(){const e=this[d],o=e.target,r=arguments.length,n=new Array(r),s=o.length;for(let t=0;t<r;t++)n[t]=m(arguments[t],s+t,e);var t=Reflect.apply(o.push,o,n);const i=[];for(let t=s,e=o.length;t<e;t++)i[t-s]=new O(w,[t],o[t],void 0,this);return j(e,i),t},shift:function(){const t=this[d],e=t.target;let o,r,n,s,i;for((o=e.shift())&&"object"==typeof o&&(i=o[d])&&(o=i.detach()),r=0,n=e.length;r<n;r++)(s=e[r])&&"object"==typeof s&&(i=s[d])&&(i.ownKey=r);var h=[new O(g,[0],void 0,o,this)];return j(t,h),o},unshift:function(){const e=this[d],r=e.target,o=arguments.length,n=new Array(o);for(let t=0;t<o;t++)n[t]=m(arguments[t],t,e);var t=Reflect.apply(r.unshift,r,n);for(let t=0,e=r.length,o;t<e;t++)if((o=r[t])&&"object"==typeof o){const h=o[d];h&&(h.ownKey=t)}var s=n.length;const i=new Array(s);for(let t=0;t<s;t++)i[t]=new O(w,[t],r[t],void 0,this);return j(e,i),t},reverse:t,sort:e,fill:s,copyWithin:i,splice:function(){const e=this[d],o=e.target,r=arguments.length,n=new Array(r),f=o.length;for(let t=0;t<r;t++)n[t]=m(arguments[t],t,e);const t=0===r?0:n[0]<0?f+n[0]:n[0],p=r<2?f-t:n[1],c=Math.max(r-2,0),s=Reflect.apply(o.splice,o,n),b=o.length;let i;for(let t=0,e;t<b;t++)(e=o[t])&&"object"==typeof e&&(i=e[d])&&(i.ownKey=t);let h,y,u;for(h=0,y=s.length;h<y;h++)(u=s[h])&&"object"==typeof u&&(i=u[d])&&(s[h]=i.detach());const a=[];let l;for(l=0;l<p;l++)l<c?a.push(new O(v,[t+l],o[t+l],s[l],this)):a.push(new O(g,[t+l],void 0,s[l],this));for(;l<c;l++)a.push(new O(w,[t+l],o[t+l],void 0,this));return j(e,a),s}},M={reverse:t,sort:e,fill:s,copyWithin:i,set:function(t,e){const o=this[d],r=o.target,n=t.length,s=r.slice(0),i=(e=e||0,r.set(t,e),new Array(n));for(let t=e;t<n+e;t++)i[t-e]=new O(v,[t],r[t],s[t],this);j(o,i)}};class O{constructor(t,e,o,r,n){this.type=t,this.path=e,this.value=o,this.oldValue=r,this.object=n}}class A{constructor(t,e){var{target:o,parent:r,ownKey:n}=t,r=(r&&void 0!==n?(this.parent=r,this.ownKey=n):(this.parent=null,this.ownKey=null),e(o,this));this.observers=[],this.revocable=Proxy.revocable(r,this),this.proxy=this.revocable.proxy,this.target=r,this.options=this.processOptions(t.options),this.options.async&&(this.batches=[])}processOptions(t){if(t){if("object"!=typeof t)throw new Error(`Observable options if/when provided, MAY only be an object, got '${t}'`);const e=Object.keys(t).filter(t=>!(t in l));if(e.length)throw new Error(`'${e.join(", ")}' is/are not a valid Observable option/s`);return Object.assign({},t)}return{}}detach(){return this.parent=null,this.target}set(t,e,o){let r=t[e];if(o!==r){o=m(o,e,this);if(t[e]=o,r&&"object"==typeof r){const n=r[d];n&&(r=n.detach())}t=void 0===r?[new O(w,[e],o,void 0,this.proxy)]:[new O(v,[e],o,r,this.proxy)];j(this,t)}return!0}deleteProperty(t,e){let o=t[e];if(delete t[e],o&&"object"==typeof o){const r=o[d];r&&(o=r.detach())}t=[new O(g,[e],void 0,o,this.proxy)];return j(this,t),!0}}class K extends A{constructor(t){super(t,f)}}class E extends A{constructor(t){super(t,p)}get(t,e){return x[e]||t[e]}}class S extends A{constructor(t){super(t,c)}get(t,e){return M[e]||t[e]}}const n=Object.freeze({from:(t,e)=>{if(t&&"object"==typeof t){if(t[d])return t;if(Array.isArray(t))return new E({target:t,ownKey:null,parent:null,options:e}).proxy;if(ArrayBuffer.isView(t))return new S({target:t,ownKey:null,parent:null,options:e}).proxy;if(t instanceof Date)throw new Error(t+" found to be one of a non-observable types");return new K({target:t,ownKey:null,parent:null,options:e}).proxy}throw new Error("observable MAY ONLY be created from a non-null object")},isObservable:t=>!(!t||!t[d]),observe:(t,e,o)=>{if(!n.isObservable(t))throw new Error("invalid observable parameter");if("function"!=typeof e)throw new Error(`observer MUST be a function, got '${e}'`);const r=t[d].observers;r.some(t=>t[0]===e)?console.warn("observer may be bound to an observable only once; will NOT rebind"):r.push([e,(t=>{if(!t||"object"!=typeof t)return null;const e={},o=[];for(var[r,n]of Object.entries(t))if("path"===r){if("string"!=typeof n||""===n)throw new Error('"path" option, if/when provided, MUST be a non-empty string');e[r]=n}else if("pathsOf"===r){if(t.path)throw new Error('"pathsOf" option MAY NOT be specified together with "path" option');if("string"!=typeof n)throw new Error('"pathsOf" option, if/when provided, MUST be a string (MAY be empty)');e[r]=t.pathsOf.split(".").filter(Boolean)}else if("pathsFrom"===r){if(t.path||t.pathsOf)throw new Error('"pathsFrom" option MAY NOT be specified together with "path"/"pathsOf" option/s');if("string"!=typeof n||""===n)throw new Error('"pathsFrom" option, if/when provided, MUST be a non-empty string');e[r]=n}else o.push(r);if(o.length)throw new Error(`'${o.join(", ")}' is/are not a valid observer option/s`);return e})(o)])},unobserve:(t,...e)=>{if(!n.isObservable(t))throw new Error("invalid observable parameter");const o=t[d].observers;let r=o.length;if(r)if(e.length)for(;r;)0<=e.indexOf(o[--r][0])&&o.splice(r,1);else o.splice(0)}}),o=Symbol("observer-key"),r=Symbol("targets-key");class T{constructor(t){this[o]=t,this[r]=new Set,Object.freeze(this)}observe(t,e){t=n.from(t);return n.observe(t,this[o],e),this[r].add(t),t}unobserve(t){n.unobserve(t,this[o]),this[r].delete(t)}disconnect(){for(const t of this[r])n.unobserve(t,this[o]);this[r].clear()}}export{n as Observable,T as ObjectObserver};